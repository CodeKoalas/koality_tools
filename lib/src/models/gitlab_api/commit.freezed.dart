// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'commit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

GitlabCommit _$GitlabCommitFromJson(Map<String, dynamic> json) {
  return _GitlabCommit.fromJson(json);
}

/// @nodoc
mixin _$GitlabCommit {
  String get id => throw _privateConstructorUsedError;
  String get shortId => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get message => throw _privateConstructorUsedError;
  List<String> get parentIds => throw _privateConstructorUsedError;
  String get authorName => throw _privateConstructorUsedError;
  String get authorEmail => throw _privateConstructorUsedError;
  String get authoredDate => throw _privateConstructorUsedError;
  String get committerName => throw _privateConstructorUsedError;
  String get committerEmail => throw _privateConstructorUsedError;
  String get committedDate => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GitlabCommitCopyWith<GitlabCommit> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GitlabCommitCopyWith<$Res> {
  factory $GitlabCommitCopyWith(GitlabCommit value, $Res Function(GitlabCommit) then) =
      _$GitlabCommitCopyWithImpl<$Res, GitlabCommit>;
  @useResult
  $Res call(
      {String id,
      String shortId,
      String title,
      String message,
      List<String> parentIds,
      String authorName,
      String authorEmail,
      String authoredDate,
      String committerName,
      String committerEmail,
      String committedDate});
}

/// @nodoc
class _$GitlabCommitCopyWithImpl<$Res, $Val extends GitlabCommit> implements $GitlabCommitCopyWith<$Res> {
  _$GitlabCommitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? shortId = null,
    Object? title = null,
    Object? message = null,
    Object? parentIds = null,
    Object? authorName = null,
    Object? authorEmail = null,
    Object? authoredDate = null,
    Object? committerName = null,
    Object? committerEmail = null,
    Object? committedDate = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      shortId: null == shortId
          ? _value.shortId
          : shortId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      parentIds: null == parentIds
          ? _value.parentIds
          : parentIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      authorName: null == authorName
          ? _value.authorName
          : authorName // ignore: cast_nullable_to_non_nullable
              as String,
      authorEmail: null == authorEmail
          ? _value.authorEmail
          : authorEmail // ignore: cast_nullable_to_non_nullable
              as String,
      authoredDate: null == authoredDate
          ? _value.authoredDate
          : authoredDate // ignore: cast_nullable_to_non_nullable
              as String,
      committerName: null == committerName
          ? _value.committerName
          : committerName // ignore: cast_nullable_to_non_nullable
              as String,
      committerEmail: null == committerEmail
          ? _value.committerEmail
          : committerEmail // ignore: cast_nullable_to_non_nullable
              as String,
      committedDate: null == committedDate
          ? _value.committedDate
          : committedDate // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GitlabCommitImplCopyWith<$Res> implements $GitlabCommitCopyWith<$Res> {
  factory _$$GitlabCommitImplCopyWith(_$GitlabCommitImpl value, $Res Function(_$GitlabCommitImpl) then) =
      __$$GitlabCommitImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String shortId,
      String title,
      String message,
      List<String> parentIds,
      String authorName,
      String authorEmail,
      String authoredDate,
      String committerName,
      String committerEmail,
      String committedDate});
}

/// @nodoc
class __$$GitlabCommitImplCopyWithImpl<$Res> extends _$GitlabCommitCopyWithImpl<$Res, _$GitlabCommitImpl>
    implements _$$GitlabCommitImplCopyWith<$Res> {
  __$$GitlabCommitImplCopyWithImpl(_$GitlabCommitImpl _value, $Res Function(_$GitlabCommitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? shortId = null,
    Object? title = null,
    Object? message = null,
    Object? parentIds = null,
    Object? authorName = null,
    Object? authorEmail = null,
    Object? authoredDate = null,
    Object? committerName = null,
    Object? committerEmail = null,
    Object? committedDate = null,
  }) {
    return _then(_$GitlabCommitImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      shortId: null == shortId
          ? _value.shortId
          : shortId // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      parentIds: null == parentIds
          ? _value._parentIds
          : parentIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      authorName: null == authorName
          ? _value.authorName
          : authorName // ignore: cast_nullable_to_non_nullable
              as String,
      authorEmail: null == authorEmail
          ? _value.authorEmail
          : authorEmail // ignore: cast_nullable_to_non_nullable
              as String,
      authoredDate: null == authoredDate
          ? _value.authoredDate
          : authoredDate // ignore: cast_nullable_to_non_nullable
              as String,
      committerName: null == committerName
          ? _value.committerName
          : committerName // ignore: cast_nullable_to_non_nullable
              as String,
      committerEmail: null == committerEmail
          ? _value.committerEmail
          : committerEmail // ignore: cast_nullable_to_non_nullable
              as String,
      committedDate: null == committedDate
          ? _value.committedDate
          : committedDate // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GitlabCommitImpl extends _GitlabCommit {
  const _$GitlabCommitImpl(
      {required this.id,
      required this.shortId,
      this.title = '',
      this.message = '',
      final List<String> parentIds = const <String>[],
      this.authorName = '',
      this.authorEmail = '',
      this.authoredDate = '',
      this.committerName = '',
      this.committerEmail = '',
      this.committedDate = ''})
      : _parentIds = parentIds,
        super._();

  factory _$GitlabCommitImpl.fromJson(Map<String, dynamic> json) => _$$GitlabCommitImplFromJson(json);

  @override
  final String id;
  @override
  final String shortId;
  @override
  @JsonKey()
  final String title;
  @override
  @JsonKey()
  final String message;
  final List<String> _parentIds;
  @override
  @JsonKey()
  List<String> get parentIds {
    if (_parentIds is EqualUnmodifiableListView) return _parentIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parentIds);
  }

  @override
  @JsonKey()
  final String authorName;
  @override
  @JsonKey()
  final String authorEmail;
  @override
  @JsonKey()
  final String authoredDate;
  @override
  @JsonKey()
  final String committerName;
  @override
  @JsonKey()
  final String committerEmail;
  @override
  @JsonKey()
  final String committedDate;

  @override
  String toString() {
    return 'GitlabCommit(id: $id, shortId: $shortId, title: $title, message: $message, parentIds: $parentIds, authorName: $authorName, authorEmail: $authorEmail, authoredDate: $authoredDate, committerName: $committerName, committerEmail: $committerEmail, committedDate: $committedDate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GitlabCommitImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.shortId, shortId) || other.shortId == shortId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._parentIds, _parentIds) &&
            (identical(other.authorName, authorName) || other.authorName == authorName) &&
            (identical(other.authorEmail, authorEmail) || other.authorEmail == authorEmail) &&
            (identical(other.authoredDate, authoredDate) || other.authoredDate == authoredDate) &&
            (identical(other.committerName, committerName) || other.committerName == committerName) &&
            (identical(other.committerEmail, committerEmail) || other.committerEmail == committerEmail) &&
            (identical(other.committedDate, committedDate) || other.committedDate == committedDate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      shortId,
      title,
      message,
      const DeepCollectionEquality().hash(_parentIds),
      authorName,
      authorEmail,
      authoredDate,
      committerName,
      committerEmail,
      committedDate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GitlabCommitImplCopyWith<_$GitlabCommitImpl> get copyWith =>
      __$$GitlabCommitImplCopyWithImpl<_$GitlabCommitImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GitlabCommitImplToJson(
      this,
    );
  }
}

abstract class _GitlabCommit extends GitlabCommit {
  const factory _GitlabCommit(
      {required final String id,
      required final String shortId,
      final String title,
      final String message,
      final List<String> parentIds,
      final String authorName,
      final String authorEmail,
      final String authoredDate,
      final String committerName,
      final String committerEmail,
      final String committedDate}) = _$GitlabCommitImpl;
  const _GitlabCommit._() : super._();

  factory _GitlabCommit.fromJson(Map<String, dynamic> json) = _$GitlabCommitImpl.fromJson;

  @override
  String get id;
  @override
  String get shortId;
  @override
  String get title;
  @override
  String get message;
  @override
  List<String> get parentIds;
  @override
  String get authorName;
  @override
  String get authorEmail;
  @override
  String get authoredDate;
  @override
  String get committerName;
  @override
  String get committerEmail;
  @override
  String get committedDate;
  @override
  @JsonKey(ignore: true)
  _$$GitlabCommitImplCopyWith<_$GitlabCommitImpl> get copyWith => throw _privateConstructorUsedError;
}
