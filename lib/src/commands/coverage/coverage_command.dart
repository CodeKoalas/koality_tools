import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:mason_logger/mason_logger.dart';
import 'package:sprintf/sprintf.dart';

/// {@template coverage_command}
///
/// `koality coverage`
/// A [Command] that creates a file referencing all code files to make sure coverage is run on all files.
/// {@endtemplate}
class CoverageCommand extends Command<int> {
  /// {@macro coverage_command}
  CoverageCommand({
    required Logger logger,
  }) : _logger = logger {
    argParser.addOption(
      'package',
      abbr: 'p',
      mandatory: true,
      help: 'The package name for the imports.',
    );
  }

  @override
  String get description => 'A command that creates a coverage helper file.';

  @override
  String get name => 'coverage';

  final Logger _logger;

  final List<String> fileLines = [
    '// Helper file to make coverage work for all dart files\n',
    '// **************************************************************************\n',
    '// Because of this: https://github.com/flutter/flutter/issues/27997#issue-410722816\n',
    '// DO NOT EDIT THIS FILE\n',
    '// **************************************************************************\n',
    '\n',
    '// ignore_for_file: unused_import\n',
  ];

  final List<String> ignoredFiles = [
    'generated_plugin_registrant.dart',
    'freezed.dart',
    'part.dart',
    'gr.dart',
    'g.dart',
  ];

  void createCoverageHelperFile(File file) {
    file.createSync();
    for (final line in fileLines) {
      file.writeAsStringSync(sprintf(line, const <String>[]));
    }
  }

  @override
  Future<int> run() async {
    final packageName = argResults?['package'] as String;
    _logger.info('Creating coverage helper file');
    final file = File('test/coverage_helper_test.dart');
    try {
      if (!file.existsSync()) {
        createCoverageHelperFile(file);
      } else {
        file.deleteSync();
        // Now recreate.
        createCoverageHelperFile(file);
      }
      // Now need to loop over the entire `lib` folder and add all dart files
      // that do not end with our 'ignored_files' list. Then we need to trim off
      // the last 4 characters (dart) and add the package name to the front.
      final importsToAdd = Directory('lib')
          .listSync(recursive: true)
          .where((element) => element.path.endsWith('.dart'))
          .where((element) => !ignoredFiles.any((file) => element.path.endsWith(file)))
          .where((element) {
            // We need to check if this file has a "part-of" directive at the top
            // and if it does we need to skipp it.
            final file = File(element.path);
            final lines = file.readAsLinesSync();
            return !lines.any((line) => line.contains('part of'));
          })
          .map((e) => e.path.substring(4))
          .map((e) => sprintf("import 'package:%s/%s';\n", [packageName, e]))
          .toList();
      for (final importLine in importsToAdd) {
        _logger.info(importLine);
        file.writeAsStringSync(importLine, mode: FileMode.append);
      }

      // Now write last line.
      file.writeAsStringSync('\nvoid main(){}', mode: FileMode.append);
    } catch (e) {
      _logger.err('Failed to create coverage helper file');
      return ExitCode.software.code;
    }

    return ExitCode.success.code;
  }
}
